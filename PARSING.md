# Lobby File Parsing & Game Service Architecture

## Overview

The BarcodeRevealTool monitors StarCraft II games by reading a lobby file generated by the SC2 process. When a player enters a multiplayer game, SC2 writes lobby metadata to a binary file, which the tool reads, parses, and uses to extract opponent information and query match history.

---

## File System Paths

### Lobby File Location
```
C:\Users\{username}\AppData\Local\Temp\Starcraft II\TempWriteReplayP1\replay.server.battlelobby
```

**Key Points:**
- Binary file written by SC2 process when match starts
- Contains encrypted/binary player information (names, tags, team assignments)
- File exists only while match is in progress
- Typically 1-2 KB in size

### Replay Files Location (Configurable)
```
C:\Users\{username}\Documents\StarCraft II\Accounts\{AccountID}\Replays\Multiplayer\
```

**Key Points:**
- SC2 replay files use `.SC2Replay` extension
- Each replay is a complete record of a match
- Stored after match concludes
- Used for cache population and build order extraction

---

## Parsing Pipeline

### Phase 1: Game State Monitoring

**GameEngine.MonitorGameStateAsync()** (runs every 1500ms)

```
Check SC2 process running?
    ↓ Yes
Check lobby file exists at TempWriteReplayP1 path?
    ↓ Yes: State = InGame
    ↓ No:  State = Awaiting
    ↓
Fire state change event if different from last check
    ↓
If entering InGame:
    → Sync replays from disk
    → Process lobby file
If exiting InGame:
    → Save the just-played replay to database
```

**State Transitions:**
- **Awaiting → InGame**: Lobby file appears = player entered match
- **InGame → Awaiting**: Lobby file disappears = player left/finished match

---

### Phase 2: Lobby File Reading

**GameEngine.ProcessLobbyAsync()**

```csharp
1. Read lobby file as raw bytes
   File.ReadAllBytes(LobbyFilePath)
   
2. Pass bytes to GameLobbyFactory
   var lobby = _gameLobbyFactory.CreateLobby(lobbyBytes, settings)
   
3. Load additional data in parallel:
   - SC2Pulse opponent stats (ratings, rank, etc.)
   - Queue type detection (1v1, 2v2, 3v3, 4v4)
   
4. Cache the parsed lobby object for display
   _cachedLobby = lobby as ISoloGameLobby
   
5. Display lobby info to console
   DisplayCurrentState()
```

---

### Phase 3: Binary Parsing - GameLobbyFactory

**GameLobbyFactory.CreateLobby(byte[] lobbyBytes, AppSettings settings)**

#### Step 1: Convert Bytes to Searchable String

```csharp
var lobbyText = new string(lobbyBytes.Select(b => (char)b).ToArray());
```

The binary lobby file contains embedded text for player information. By converting bytes to characters, we can search for battle tags using regex.

#### Step 2: Extract Battle Tags via Regex

```csharp
private static readonly Regex PlayerPattern = 
    new("(?<name>[A-Za-z][A-Za-z0-9]{2,20}#[0-9]{3,6})");
```

**Pattern Match Format:**
```
BattleTag# format examples:
- AlphaGamer#123
- XLover#2803
- ProPlayer#99999

Matches ANYWHERE in the binary data where this pattern appears
```

**Extraction Result:**
```
Raw matches (may include duplicates):
[0] = Player1Nick#1234
[1] = Player1Nick#1234  (duplicate)
[2] = Player1Tag#XXXX
[3] = Player2Nick#5678
[4] = Player2Nick#5678  (duplicate)
[5] = Player2Tag#YYYY
...

Pattern: Each player appears 3 times in binary (2 duplicates + 1 unique tag)
```

#### Step 3: Deduplicate and Identify User

```csharp
var matches = PlayerPattern.Matches(lobbyText)
    .Cast<Match>()
    .Select(m => m.Groups["name"].Value)
    .Distinct(StringComparer.OrdinalIgnoreCase)
    .ToList();

if (matches.Count >= 2) {
    // Match configured user tag to lobby player
    var normalizedUser = NormalizeTag(settings.User.BattleTag);
    var yourTag = matches.FirstOrDefault(m => 
        NormalizeTag(m).Equals(normalizedUser, StringComparison.OrdinalIgnoreCase))
    ?? matches[0];  // Fallback to first player if not found
    
    // Other match is the opponent
    var opponentTag = (yourTag == matches[0]) ? matches[1] : matches[0];
}
```

#### Step 4: Create Team Objects

```csharp
// Create Player objects from tags
var yourPlayer = new Player {
    NickName = ExtractNickname(yourTag),      // "XLover"
    Tag = yourTag,                             // "XLover#2803"
    Race = DetectRaceIfAvailable()
};

var opponentPlayer = new Player {
    NickName = ExtractNickname(opponentTag),  // "ProPlayer"
    Tag = opponentTag,                         // "ProPlayer#5555"
    Race = DetectRaceIfAvailable()
};

// Create teams
var yourTeam = new Team { Players = [yourPlayer] };
var oppTeam = new Team { Players = [opponentPlayer] };
```

#### Step 5: Return Lobby Object

```csharp
return new GameLobby(yourTeam, oppTeam, opponentTag);
```

---

## Game Service Flow

### GameEngine - Main Orchestrator

**Responsibilities:**
- Monitor SC2 process (is it running?)
- Monitor lobby file (does it exist?)
- Coordinate state transitions
- Trigger cache/replay syncing
- Display UI via IOutputProvider

**Key Properties:**
```csharp
CurrentState              // Awaiting or InGame
_cachedLobby             // Parsed lobby object (valid only in InGame state)
LobbyFilePath            // Path to SC2 lobby file
_cacheInitialized        // Has cache been loaded?
_gameStateManager        // Tracks process/file state
```

**Event Loop:**
```
Main thread:
  1. Initialize cache (first run only)
  2. Start background monitoring threads
  3. Wait for cancellation

Background thread 1: MonitorGameStateAsync()
  - Every 1500ms: Check if lobby file exists
  - Update CurrentState
  - Trigger ProcessLobbyAsync() on InGame transition
  - Trigger OnExitingGameAsync() on Awaiting transition

Background thread 2: MonitorSc2ProcessAsync()
  - Every 2000ms: Check if SC2 process is running
  - Refresh display if process state changes
```

---

### Replay Service - Cache & History

**Responsibilities:**
- Initialize SQLite replay cache (first run)
- Sync new replays from disk folder
- Query opponent match history
- Retrieve cached build orders
- Track game statistics

**Flow:**
```
ReplayService.InitializeCacheAsync()
  → Scan replay folder
  → Extract metadata from each .SC2Replay file using s2protocol
  → Insert into SQLite database
  → Update cache validation timestamp

ReplayService.GetOpponentMatchHistory(yourTag, opponentTag)
  → Query Replays table:
    WHERE (You = opponentTag OR Opponent = opponentTag)
    AND (You = yourTag OR Opponent = yourTag)
  → Return list of matches with winner info
  
ReplayService.SyncReplaysFromDiskAsync()
  → Compare disk replays with database
  → Process only NEW replays (not already cached)
  → Insert build orders into BuildOrderEntries table
```

---

## Data Flow Diagram

```
StarCraft II Process
        ↓
        └─→ Writes: replay.server.battlelobby (binary)
                    ↓
        GameEngine.MonitorGameStateAsync()
                    ↓
        File.Exists(LobbyFilePath)? → Yes, enter InGame
                    ↓
        GameEngine.ProcessLobbyAsync()
                    ↓
        GameLobbyFactory.CreateLobby()
                    ↓
        1. Convert bytes to string
        2. Regex extract battle tags
        3. Identify user vs opponent
        4. Create Team objects
                    ↓
        ISoloGameLobby (_cachedLobby)
                    ↓
        DisplayCurrentState()
                    ↓
        SpectreConsoleOutputProvider.RenderInGameState()
                    ↓
            Display:
            - Your team: NickName (Tag)
            - Opponent team: NickName (Tag)
            - Match history (last 5 games)
            - Build orders (if cached)
                    ↓
        Also query SC2Pulse in parallel:
                    ↓
        Opponent ladder stats, MMR, league

End of match:
        ↓
        Lobby file disappears
                    ↓
        GameEngine detects state = Awaiting
                    ↓
        GameEngine.OnExitingGameAsync()
                    ↓
        Replay file appears in StarCraft II folder
                    ↓
        ReplayService.SaveReplayToDbAsync()
                    ↓
        s2protocol reads .SC2Replay
        Extract: winner, players, build order, map, etc.
                    ↓
        Insert into SQLite database
```

---

## Lobby Object Structure

```csharp
public interface ISoloGameLobby {
    Team Team1 { get; }              // Your team
    Team Team2 { get; }              // Opponent team
    Queue? DetectedQueue { get; }    // 1v1, 2v2, 3v3, 4v4
    object? AdditionalData { get; }  // SC2Pulse data (LadderDistinctCharacter)
    ISoloGameLobby Parent { get; }
    Task EnsureAdditionalDataLoadedAsync();  // Load SC2Pulse data
}

public class Team {
    public string Name { get; set; }
    public List<Player> Players { get; set; }  // 1 player per slot in 1v1
}

public class Player {
    public string NickName { get; set; }      // Display name (XLover)
    public string Tag { get; set; }           // Battle tag (XLover#2803)
    public string Race { get; set; }          // Protoss, Terran, Zerg
}
```

---

## Timing Considerations

### State Check Interval
- **Hard-coded to 1500ms** (non-configurable)
- Every 1500ms, check lobby file existence
- Balance between responsiveness and system load

### SC2 Process Check
- **Hard-coded to 2000ms**
- Independent of state check
- Ensures UI updates if SC2 crashes unexpectedly

### Cache Initialization
- **Synchronous on first run**
- Blocks until all replays are processed
- Prevents game state monitoring until cache is ready
- Subsequent runs use incremental sync (faster)

### Match Detection Latency
- Lobby file appears ~100-500ms after clicking "Play"
- State detected next check cycle (0-1500ms delay)
- Total user-visible latency: ~0.1-2.0 seconds

---

## Error Handling

### Lobby File Not Found
```
→ State remains Awaiting
→ Retry next cycle
→ Graceful handling (no exception)
```

### Parsing Fails
```
→ GameLobbyFactory returns null
→ Display warning: "Failed to parse lobby data"
→ Try again next check cycle
```

### SC2Pulse API Timeout
```
→ Timeout after 5 seconds
→ Proceed with available lobby info
→ AdditionalData remains null
→ Opponent stats not displayed, but match history still works
```

### Replay File Corruption
```
→ s2protocol throws exception
→ Catch and log error
→ Skip that replay file
→ Continue with next file
→ No database pollution
```

---

## Normalization & Matching

### Tag Normalization
```csharp
// Replace underscores with hashes (legacy support)
private static string NormalizeTag(string? tag)
    => string.IsNullOrWhiteSpace(tag) 
        ? string.Empty 
        : tag.Replace('_', '#').Trim();
```

**Examples:**
- `XLover_2803` → `XLover#2803`
- `XLover#2803` → `XLover#2803`
- `XLOVER#2803` → `XLOVER#2803` (case preserved, search is OrdinalIgnoreCase)

### Toon Handle Normalization
```csharp
// Format: "region-S2-realm-battleNetId"
// Example: "1-S2-2-1369255" → "S2-2-1369255"
private static string NormalizeToonHandle(string toonHandle) {
    if (string.IsNullOrEmpty(toonHandle)) return string.Empty;
    
    var parts = toonHandle.Split('-');
    if (parts.Length >= 3 && parts[0].Length == 1 && char.IsDigit(parts[0][0]) && parts[1] == "S2") {
        return string.Join("-", parts, 1, parts.Length - 1);
    }
    return toonHandle;
}
```

---

## Summary

The parsing flow is:

1. **Monitor** - GameEngine checks lobby file every 1500ms
2. **Read** - On state change, read binary lobby file
3. **Parse** - GameLobbyFactory extracts battle tags using regex
4. **Identify** - Match configured user to lobby player
5. **Create** - Build Team/Player objects with nicknames and tags
6. **Query** - Fetch opponent history from replay database
7. **Display** - Render lobby info and match history to console
8. **Save** - On match exit, save replay to database for future queries

This architecture keeps the game state monitoring separate from the replay service, allowing both to operate independently while working together to provide complete opponent intelligence.
